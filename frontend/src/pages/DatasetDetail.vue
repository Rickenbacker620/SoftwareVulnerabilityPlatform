<template lang="pug">
div.grid.grid-cols-5
    div.col-span-4.px-4.my-4
        div.h-32.flex.flex-wrap.space-x-16.items-center
            NSpace
                NButton(v-for="category in categories" :key="category.en" type="success" size="small" round ghost @click="() => makeAnnotation(category.en)") {{ category.zh }} 快捷键 {{ category.key }}
        div.pb-10
            AnnotationArea(
                v-for="annotation in annotationsView"
            :key="annotation.start"
            :text="grepText(annotation)"
            :part="annotation.part"
            :partzh="tozh(annotation.part)"
            @click="handleClick(annotation)")


    div.flex.flex-col.col-span-1.px-5.space-y-3.items-center.mt-10
        div.flex.flex-row.space-x-2
            NCheckBox
            NButton(v-if="user.role === 'admin'" strong round type="success" :ghost="!dataset.approved" @click="toggleApproved") 通过
            NButton(v-if="user.role === 'admin'" strong round type="warning" :ghost="!dataset.ambiguous" @click="toggleAmbiguous") 存疑
            NButton(strong round type="error" :ghost="!dataset.invalid" @click="toggleInvalid") 无效
        SelectAnnotationPanel(v-if="selAnnotation" :part="selAnnotation.part")
        NButton(v-if="selAnnotation" @click="deleteAnnotation" tertiary round ghost type="error") 删除


</template>

<script setup lang="ts">
import type { DatasetDetailSchema } from "@/api"
import { annotationService, datasetService } from "@/utils/services"
import { computed, ref } from "@vue/runtime-core"
import hotkeys from "hotkeys-js"
import AnnotationArea from "@/components/AnnotationArea.vue"
import { useMessage } from "naive-ui"
import {
    annotationWithCursor,
    fillIntervals,
    simplifyDate,
} from "@/utils/others"
import { useCursorStore } from "@/stores/cursor"
import SelectAnnotationPanel from "@/components/SelectAnnotationPanel.vue"
import _ from "lodash-es"
import { useUserStore } from "@/stores/user"
import { NGradientText } from "naive-ui"

const toggleApproved = () => {
    datasetService
        .toggleStatus(props.id, "approved")
        .then((response) => response.data)
        .then((data) => {
            dataset.value.approved = !dataset.value.approved
            message.success(data.message)
        })
}

const toggleAmbiguous = () => {
    datasetService
        .toggleStatus(props.id, "ambiguous")
        .then((response) => response.data)
        .then((data) => {
            dataset.value.ambiguous = !dataset.value.ambiguous
            message.success(data.message)
        })
}

const toggleInvalid = () => {
    datasetService
        .toggleStatus(props.id, "invalid")
        .then((response) => response.data)
        .then((data) => {
            dataset.value.invalid = !dataset.value.invalid
            message.success(data.message)
        })
}

// const markAmbiguous = () => {datasetService.markAsAmbiguous(props.id)}

const message = useMessage()
const user = useUserStore()

const props = defineProps<{ id: string }>()

const categories = [
    { key: "q", en: "cause", zh: "产生原因" },
    { key: "w", en: "location", zh: "漏洞位置" },
    { key: "e", en: "situation", zh: "发生情境" },
    { key: "r", en: "version", zh: "涉及版本" },
    { key: "a", en: "attacker", zh: "触发者" },
    { key: "s", en: "operation", zh: "触发操作" },
    { key: "d", en: "consequence", zh: "漏洞后果" },
]

const tozh = (en) => {
    const category = categories.find((e) => e.en === en)
    return category?.zh ?? ""
}

const grepText = (e) =>
    dataset.value.description.slice(e.start_offset, e.end_offset)

const annotationsView = computed(() => {
    const annotationsRaw = dataset.value.annotations ?? []
    let withCursor
    switch (cursor.mode) {
        case "none":
            return fillIntervals(
                annotationsRaw,
                dataset.value.description.length,
            )
        case "pending":
            withCursor = annotationWithCursor(
                annotationsRaw,
                cursor.position,
                cursor.mode,
            )
            return fillIntervals(withCursor, dataset.value.description.length)
        case "select":
            withCursor = annotationWithCursor(
                annotationsRaw,
                cursor.position,
                cursor.mode,
            )
            return fillIntervals(withCursor, dataset.value.description.length)
        default:
            return fillIntervals(
                annotationsRaw,
                dataset.value.description.length,
            )
    }
})

const query = () => {
    return datasetService
        .getDataset(props.id)
        .then((res) => res.data)
        .then((data) => simplifyDate(data))
}

const selAnnotation = ref()

const handleClick = (e) => {
    if (!["pending", "select", "plain"].includes(e.part)) {
        selAnnotation.value = e
    }
}

const dataset = ref<DatasetDetailSchema>(await query())
dataset.value.annotations?.sort((a, b) => a.start_offset - b.end_offset)

const cursor = useCursorStore()
cursor.initialize(dataset.value.description)

const deleteAnnotation = () => {
    annotationService
        .deleteAnnotation(props.id, selAnnotation.value)
        .then((_) => message.success("删除成功"))
        .catch((_) => message.error("删除失败"))
    _.pull(dataset.value?.annotations ?? [], selAnnotation.value)
    selAnnotation.value = undefined
}

const setupKeys = () => {
    hotkeys.unbind()
    hotkeys(
        "right,left,ctrl+right,ctrl+left,space,esc",
        function (event, handler) {
            event.preventDefault()
            switch (handler.key) {
                case "right":
                    cursor.move("right", 1)
                    break
                case "left":
                    cursor.move("left", 1)
                    break
                case "ctrl+right":
                    cursor.move("right", 5)
                    break
                case "ctrl+left":
                    cursor.move("left", 5)
                    break
                case "space":
                    cursor.hoistCursor()
                    break
                case "esc":
                    cursor.lowerCursor()
                    break
                default:
                    break
            }
        },
    )

    const catKeys = categories.map((e) => e.key).join(",")

    hotkeys(catKeys, function (event, handler) {
        if (cursor.mode != "select") return
        const part = categories.find((e) => e.key === handler.key)!.en

        makeAnnotation(part)
    })
}

setupKeys()

function makeAnnotation(part: string) {
    const newAnnotation = {
        start_offset: cursor.position[0],
        end_offset: cursor.position[1],
        part: part,
    }
    annotationService
        .createAnnotation(props.id, newAnnotation)
        .then((_) => message.success("添加成功"))
        .catch((_) => message.error("添加失败"))
    dataset.value.annotations?.push(newAnnotation)
    dataset.value.annotations?.sort((a, b) => a.start_offset - b.end_offset)
    cursor.afterAnnotationIndex()
}
</script>

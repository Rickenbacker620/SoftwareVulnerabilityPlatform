<template lang="pug">
div.grid.grid-cols-7
    div.col-span-5.px-4.my-4
        div.h-32.flex.flex-wrap.space-x-16.items-center
            NRadioGroup(v-if="user.role==='admin'" v-model:value="selectAnnotationUser")
                NRadioButton(v-for="user in annotationUsers" :value="user", :key="user") {{user}}
            NSpace
                NButton(v-for="category in categories" :key="category.en" type="success" size="small" round ghost @click="() => makeAnnotation(category.en)") {{ category.zh }} 快捷键 {{ category.key }}
        div.pb-10
            AnnotationArea(
                v-for="annotation in annotationsView"
            :key="annotation.start"
            :text="grepText(annotation)"
            :part="annotation.part"
            :partzh="tozh(annotation.part)"
            :detail="annotation.detail"
            @click="handleClick(annotation)")


    div.flex.flex-col.col-span-2.px-5.space-y-6.items-center.mt-10
        div.text-lg {{ id }}
        div.text-lg {{ dataset.cwe_id }}
        div.text-lg {{ dataset.cwe_name }}
        div.flex.flex-row.space-x-2
            NButton(@click="openExternalUrl(`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${id}`)") CVE
            NButton(@click="openExternalUrl(`https://nvd.nist.gov/vuln/detail/${id}`)") NVD
            NButton(@click="openExternalUrl(`https://exchange.xforce.ibmcloud.com/vulnerabilities/${id}`)") XFORCE
        div.flex.flex-row.space-x-2
            div(v-for="(status, key) in statusButtonDict" :key="key")
                NButton(v-if="status.roles.includes(user.role)" strong :type="status.type" :ghost="!dataset.tags?.includes(key)" @click="toggleStatus(key)") {{status.zh}}
        SelectAnnotationPanel(v-if="selAnnotation" :annotation="dataset.annotations?.find(e => e.id===selAnnotation.id)")
        NButton(v-if="selAnnotation" @click="deleteAnnotation" round type="error") 删除
        NRadioGroup(v-if="selAnnotation?.part=='cause'" v-model:value="causeDetail" @update-value="changeCauseDetail")
            NRadioButton(v-for="detail in causeDetailCategories" :key="detail" :value="detail") {{detail}}


</template>

<script setup lang="ts">
import type { DatasetDetailSchema } from "@/api"
import { annotationService, datasetService } from "@/utils/services"
import { computed, ref } from "@vue/runtime-core"
import hotkeys from "hotkeys-js"
import AnnotationArea from "@/components/AnnotationArea.vue"
import { useMessage } from "naive-ui"
import {
    annotationWithCursor,
    fillIntervals,
} from "@/utils/others"
import { useCursorStore } from "@/stores/cursor"
import SelectAnnotationPanel from "@/components/SelectAnnotationPanel.vue"
import _ from "lodash-es"
import { useUserStore } from "@/stores/user"
import { watch } from "vue"

const statusButtonDict = {
    approved: { zh: "通过", type: "success", roles: ["admin"] },
    example: { zh: "示例", type: "success", roles: ["admin"] },
    ambiguous: { zh: "存疑", type: "warning", roles: ["admin"] },
    invalid: { zh: "无效", type: "error", roles: ["annotator", "admin"] },
}

const user = useUserStore()

const causeDetailCategories = ["TIM", "CON", "INP", "MEM", "LOG", "NUM", "UNK"]

const toggleStatus = (status) => {
    datasetService
        .toggleStatus(props.id, status)
        .then((response) => response.data)
        .then((data) => {
            if (!dataset.value.tags?.includes(status)) {
                dataset.value.tags?.push(status)
            } else {
                dataset.value.tags = dataset.value.tags.filter(
                    (e) => e != status,
                )
            }
            message.success(data.message)
        })
}

const message = useMessage()

const props = defineProps<{ id: string }>()

const categories = [
    { key: "q", en: "cause", zh: "产生原因" },
    { key: "w", en: "location", zh: "漏洞位置" },
    { key: "e", en: "situation", zh: "发生情境" },
    { key: "r", en: "version", zh: "涉及版本" },
    { key: "a", en: "attacker", zh: "触发者" },
    { key: "s", en: "operation", zh: "触发操作" },
    { key: "d", en: "consequence", zh: "漏洞后果" },
]

const tozh = (en) => {
    const category = categories.find((e) => e.en === en)
    return category?.zh ?? ""
}

const grepText = (e) =>
    dataset.value.description.slice(e.start_offset, e.end_offset)

const annotationsView = computed(() => {
    const annotationsRaw = visibleAnnotations.value ?? []
    let withCursor
    switch (cursor.mode) {
        case "none":
            return fillIntervals(
                annotationsRaw,
                dataset.value.description.length,
            )
        case "pending":
            withCursor = annotationWithCursor(
                annotationsRaw,
                cursor.position,
                cursor.mode,
            )
            return fillIntervals(withCursor, dataset.value.description.length)
        case "select":
            withCursor = annotationWithCursor(
                annotationsRaw,
                cursor.position,
                cursor.mode,
            )
            return fillIntervals(withCursor, dataset.value.description.length)
        default:
            return fillIntervals(
                annotationsRaw,
                dataset.value.description.length,
            )
    }
})

const query = () => {
    return datasetService
        .getDataset(props.id)
        .then((res) => res.data)
}

const selAnnotation = ref()

const handleClick = (e) => {
    if (!["pending", "select", "plain"].includes(e.part)) {
        selAnnotation.value = e
    }
}

const dataset = ref<DatasetDetailSchema>(await query())
dataset.value.annotations?.sort((a, b) => a.start_offset - b.end_offset)


const annotationUsers = computed(() => _.uniq(
    dataset.value?.annotations?.map((e) => e.annotated_by),
))

const selectAnnotationUser = ref(annotationUsers.value.includes(user.username) ? user.username : annotationUsers.value[0])

watch(annotationUsers, () => selectAnnotationUser.value = annotationUsers.value.includes(user.username) ? user.username : annotationUsers.value[0])

const visibleAnnotations = computed(() => {
    if (user.role === "admin") {
        return dataset.value?.annotations?.filter(
            (e) => e.annotated_by === selectAnnotationUser.value,
        )
    } else {
        return dataset.value?.annotations?.filter(
            (e) => e.annotated_by === user.username,
        )
    }
})

const cursor = useCursorStore()
cursor.initialize(dataset.value.description)

const deleteAnnotation = () => {
    annotationService
        .deleteAnnotation(selAnnotation.value.id)
        .then((_) => message.success("删除成功"))
        .catch((_) => message.error("删除失败"))
    _.remove(
        dataset.value?.annotations ?? [],
        (e) => e.id === selAnnotation.value.id,
    )
    selAnnotation.value = undefined
}

const setupKeys = () => {
    hotkeys.unbind()
    hotkeys(
        "right,left,ctrl+right,ctrl+left,space,esc",
        function (event, handler) {
            event.preventDefault()
            switch (handler.key) {
                case "right":
                    cursor.move("right", 1)
                    break
                case "left":
                    cursor.move("left", 1)
                    break
                case "ctrl+right":
                    cursor.move("right", 5)
                    break
                case "ctrl+left":
                    cursor.move("left", 5)
                    break
                case "space":
                    cursor.hoistCursor()
                    break
                case "esc":
                    cursor.lowerCursor()
                    break
                default:
                    break
            }
        },
    )

    const catKeys = categories.map((e) => e.key).join(",")

    hotkeys(catKeys, function (event, handler) {
        if (cursor.mode != "select") return
        const part = categories.find((e) => e.key === handler.key)!.en

        makeAnnotation(part)
    })
}

setupKeys()

function makeAnnotation(part: string) {
    const newAnnotation = {
        start_offset: cursor.position[0],
        end_offset: cursor.position[1],
        part: part,
        cve_id: props.id,
    }
    annotationService
        .createAnnotation(newAnnotation)
        .then((result) => {
            message.success("添加成功")
            dataset.value.annotations?.push(result.data)
            dataset.value.annotations?.sort(
                (a, b) => a.start_offset - b.end_offset,
            )
            cursor.afterAnnotationIndex()
        })
        .catch((_) => message.error("添加失败"))
}

const openExternalUrl = (url) => window.open(url)

const causeDetail = computed(() => selAnnotation.value.detail)
const changeCauseDetail = (detail) => {
    selAnnotation.value.detail = detail
    annotationService
        .createAnnotationDetail(selAnnotation.value.id, detail)
        .then((_) => message.success("添加成功"))
        .catch((_) => message.error("添加失败"))
}
</script>

import _ from "lodash-es";
import * as service from "@/utils/service";
import store from "@/store";

export class AnnotationVModel {
    text: string;
    length: number;
    private _cursor!: CursorVModel;
    public _annotations: AnnotationSpan[] = [];
    private readonly _actionTable: { [key: string]: () => void };
    private _canAddAnnotation: boolean = true;
    private _datasetId: number;

    constructor(text: string, datasetId: number) {
        this.text = text;
        this._datasetId = datasetId;
        this.length = text.length;
        this._cursor = new CursorVModel(text);
        this._actionTable = {
            right: this._cursor.moveRight,
            left: this._cursor.moveLeft,
            "ctrl+right": this._cursor.moveRight5,
            "ctrl+left": this._cursor.moveLeft5,
            esc: this._cursor.lowerCursor,
            space: this._cursor.hoistCursor
        };
    }

    cursorAction(key: string) {
        this._actionTable[key].call(this._cursor);
    }

    private fillPlain(annotations: AnnotationSpan[]) {
        const temp = annotations.flatMap(
            function(v) {
                if (this.idx === v.start) {
                    this.idx = v.end + 1;
                    return [v];
                } else {
                    const plain = new AnnotationSpan(
                        this.idx,
                        v.start - 1,
                        "plain"
                    );
                    this.idx = v.end + 1;
                    return [plain, v];
                }
            },
            { idx: 0 }
        );

        const last = _.last(temp);
        if (last!.end + 1 != this.length)
            temp.push(new AnnotationSpan(last!.end + 1, this.length, "plain"));
        temp.forEach(e => (e.text = this.text.slice(e.start, e.end + 1)));
        return temp;
    }

    get cursorPosition() {
        return this._cursor.position;
    }

    get annotations() {
        let temp: AnnotationSpan[];
        if (this._cursor.mode === "none") {
            temp = this._annotations;
        } else if (this._cursor.mode === "pending") {
            temp = this.annotationWithCursor(this.cursorPosition, "pending");
        } else {
            temp = this.annotationWithCursor(this.cursorPosition, "select");
        }
        return this.fillPlain(temp);
    }

    addAnnotation(...annotations: AnnotationSpan[]): void {
        this._annotations.push(...annotations);
        this._annotations.sort((a, b) => a.start - b.start);
    }

    async fetchAnnotation(datasetId: string | undefined = undefined) {
        const {
            data: annotations
        } = await service.annotationService.annotationList(datasetId);
        const temp = annotations.map(
            e => new AnnotationSpan(e.start_offset, e.end_offset, e.part)
        );
        console.log(temp);
        this.addAnnotation(...temp);
    }

    async addNewAnnotation(annotation: AnnotationSpan) {
        console.log(this._cursor.mode, this._canAddAnnotation);
        if (this._cursor.mode === "select" && this._canAddAnnotation) {
            this.addAnnotation(annotation);
            console.log("did1");
            try {
                await service.annotationService.annotationCreate({
                    dataset: this._datasetId,
                    start_offset: annotation.start,
                    end_offset: annotation.end,
                    part: parseInt(annotation.category[3])
                });
                console.log("did");
            } catch (e) {
                console.log(e);
            }
            this._cursor.afterAnnotationIndex();
        }
    }

    annotationWithCursor(
        [start, end]: [number, number],
        mode: string
    ): AnnotationSpan[] {
        const cursor = new AnnotationSpan(start, end, mode);
        const copy = [...this._annotations];
        const temp = copy.filter(
            e => e.start > cursor.end || e.end < cursor.start
        );
        this._canAddAnnotation = temp.length === copy.length ? true : false;
        temp.push(cursor);
        temp.sort((a, b) => a.start - b.start);
        return temp;
    }
}

export class AnnotationSpan {
    start: number;
    end: number;
    category: string;
    text?: string;

    constructor(start: number, end: number, category: number | string) {
        this.start = start;
        this.end = end;
        if (typeof category === "number") {
            this.category = "cat" + category.toString();
        } else if (typeof category === "string") {
            this.category = category;
        } else {
            this.category = "plain";
        }
    }
}

class CursorVModel {
    tokens: [number, number][];
    index: number = 0;
    previousIndex: number = 0;
    mode: "none" | "pending" | "select" = "none";
    constructor(text: string) {
        this.tokens = this.getTextTokenIdx(text);
    }

    afterAnnotationIndex() {
        this.mode = "pending";
        this.moveRight();
    }

    saveIndex() {
        this.previousIndex = this.index;
    }

    restoreIndex() {
        this.index = this.previousIndex;
    }

    private getTextTokenIdx(text: string) {
        const temp = [...text.matchAll(/,?\s/g)].flatMap(e => [
            (e.index ?? 1) - 1,
            (e.index ?? 1) + e[0].length
        ]);
        const pairup = _.chunk([0, ...temp, text.length - 1], 2) as [
            number,
            number
        ][];
        return pairup;
    }

    public hoistCursor() {
        switch (this.mode) {
            case "none":
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "select";
                this.saveIndex();
            default:
                this.mode = "select";
                break;
        }
    }

    public lowerCursor() {
        switch (this.mode) {
            case "select":
                this.restoreIndex();
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "none";
                this.index = 0;
                break;
            default:
                this.mode = "none";
                this.index = 0;
                break;
        }
    }

    moveRight() {
        this.move("right", 1);
    }
    moveLeft() {
        this.move("left", 1);
    }
    moveRight5() {
        this.move("right", 5);
    }
    moveLeft5() {
        this.move("left", 5);
    }

    move(direction: "left" | "right", step: number = 1) {
        const temp = {
            left: this.index - step,
            right: this.index + step
        }[direction];
        this.index = _.clamp(temp, 0, this.tokens.length - 1);
    }

    get position() {
        if (this.mode === "none") {
            return this.tokens[0];
        } else if (this.mode === "pending") {
            return this.tokens[this.index];
        } else {
            const [preSelStart, preSelEnd] = this.tokens[this.previousIndex];
            const [curSelStart, curSelEnd] = this.tokens[this.index];
            return (this.previousIndex < this.index
                ? [preSelStart, curSelEnd]
                : [curSelStart, preSelEnd]) as [number, number];
        }
    }
}

export type CategoryVModel = {
    id: number;
    text: string;
};

export function fillPlain(annotations: AnnotationSpan[], text: string) {
    const temp = annotations.flatMap(
        function(v) {
            if (this.idx === v.start) {
                this.idx = v.end + 1;
                return [v];
            } else {
                const plain = new AnnotationSpan(
                    this.idx,
                    v.start - 1,
                    "plain"
                );
                this.idx = v.end + 1;
                return [plain, v];
            }
        },
        { idx: 0 }
    );

    const last = _.last(temp);
    if (last!.end + 1 != text.length)
        temp.push(new AnnotationSpan(last!.end + 1, text.length, "plain"));
    temp.forEach(e => (e.text = text.slice(e.start, e.end + 1)));
    return temp;
}

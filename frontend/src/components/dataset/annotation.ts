import _ from "lodash-es";
import * as services from "@/utils/services";
import { AnnotationCreateSchema, AnnotationSchema } from "@/api";
import { useMessage } from "naive-ui";

type Span = [number, number];

export class AnnotationVModel {
    text: string;
    private _cursor: Cursor;
    private _annotations: BaseSpan[] = [];
    private readonly _actionTable: { [key: string]: () => void };
    private _canAddAnnotation: boolean = true;
    private _datasetId: number;

    constructor(text: string, datasetId: number) {
        this.text = text;
        this._datasetId = datasetId;
        this._cursor = new Cursor(text);
        this._actionTable = {
            right: this._cursor.moveRight,
            left: this._cursor.moveLeft,
            "ctrl+right": this._cursor.moveRight5,
            "ctrl+left": this._cursor.moveLeft5,
            esc: this._cursor.lowerCursor,
            space: this._cursor.hoistCursor,
        };
    }

    cursorAction(key: string) {
        this._actionTable[key].call(this._cursor);
    }

    afterAnnotation() {
        this._cursor.afterAnnotationIndex();
    }

    get length() {
        return this.text.length;
    }

    private fillPlain(annotations: BaseSpan[]): BaseSpan[] {
        const temp = annotations.flatMap(
            function (v) {
                if (this.idx === v.start) {
                    this.idx = v.end + 1;
                    return [v];
                } else {
                    const plain = new PlainSpan(this.idx, v.start - 1);
                    this.idx = v.end + 1;
                    return [plain, v];
                }
            },
            { idx: 0 }
        );

        const last = _.last(temp);
        if (last instanceof BaseSpan && last.end + 1 != this.length) {
            temp.push(new PlainSpan(last.end + 1, this.length));
        } else if (typeof last === "undefined") {
            temp.push(new PlainSpan(0, this.length));
        }
        temp.forEach((e) => (e.text = this.text));
        console.log(temp);

        return temp;
    }

    get cursorPosition() {
        return this._cursor.position;
    }

    get annotations() {
        let temp: BaseSpan[];
        if (this._cursor.mode === "none") {
            temp = this._annotations;
        } else if (this._cursor.mode === "pending") {
            temp = this.annotationWithCursor(this.cursorPosition, "pending");
        } else {
            temp = this.annotationWithCursor(this.cursorPosition, "select");
        }
        return this.fillPlain(temp);
    }

    addAnnotation(...annotations: AnnotationSpan[]): void {
        console.log(annotations);
        this._annotations.push(...annotations);
        this._annotations.sort((a, b) => a.start - b.start);
    }

    async fetchAnnotation() {
        const { data: annotations } =
            await services.datasetService.getDatasetAnnotations(
                this._datasetId
            );
        const temp = annotations.map((e) => new AnnotationSpan(e));
        this.addAnnotation(...temp);
    }

    removeAnnotation(id: number) {
        _.remove(
            this._annotations,
            (e) => e instanceof AnnotationSpan && e.id == id
        );
        console.log(this._annotations);
    }

    async addNewAnnotation(annotation: AnnotationCreateSchema) {
        console.log(this._cursor.mode, this._canAddAnnotation);
        if (this._cursor.mode === "select" && this._canAddAnnotation) {
            try {
                const { data } =
                    await services.annotationService.createAnnotation(
                        annotation
                    );
                this.addAnnotation(new AnnotationSpan(data));
                this._cursor.afterAnnotationIndex();
            } catch (e) {
                useMessage().error("Failed to create");
            }
        }
    }

    annotationWithCursor(
        [start, end]: [number, number],
        mode: "pending" | "select"
    ): BaseSpan[] {
        const cursor = new CursorSpan(start, end, mode);
        const copy = [...this._annotations];
        const temp = copy.filter(
            (e) => e.start > cursor.end || e.end < cursor.start
        );
        this._canAddAnnotation = temp.length === copy.length ? true : false;
        temp.push(cursor);
        temp.sort((a, b) => a.start - b.start);
        return temp;
    }
}

export abstract class BaseSpan {
    start: number;
    end: number;
    private _text?: string | undefined;

    public get text(): string | undefined {
        if (this._text) return this._text.slice(this.start, this.end + 1);
        else return "";
    }
    public set text(value: string | undefined) {
        this._text = value;
    }

    constructor(start: number, end: number) {
        this.start = start;
        this.end = end;
    }

    abstract get renderClass(): string;
}

class CursorSpan extends BaseSpan {
    mode: "pending" | "select";
    constructor(start: number, end: number, mode: "pending" | "select") {
        super(start, end);
        this.mode = mode;
    }

    get renderClass(): string {
        return this.mode;
    }
}

class PlainSpan extends BaseSpan {
    get renderClass(): string {
        return "plain";
    }
}

export class AnnotationSpan extends BaseSpan {
    id: number;
    part_id: number;
    detail_id?: number;
    dataset_id: number;

    constructor(annotation: AnnotationSchema) {
        super(annotation.start_offset, annotation.end_offset);
        this.id = annotation.id;
        this.dataset_id = annotation.dataset_id;
        this.part_id = annotation.part_id;
        this.detail_id = annotation.detail_id;
    }

    get renderClass(): string {
        return "cat" + this.part_id;
    }

    get data(): AnnotationSchema {
        return {
            id: this.id,
            dataset_id: this.dataset_id,
            start_offset: this.start,
            end_offset: this.end,
            part_id: this.part_id,
            detail_id: this.detail_id,
        };
    }
}

// export class AnnotationSpan {
//     start: number;
//     end: number;
//     category: string;
//     part_id?: number;
//     detail_id?: number;
//     text?: string;

//     constructor(start: number, end: number, category: number | string) {
//         this.start = start;
//         this.end = end;
//         if (typeof category === "number") {
//             this.category = "cat" + category.toString();
//         } else if (typeof category === "string") {
//             this.category = category;
//         } else {
//             this.category = "plain";
//         }
//     }
// }

export class Cursor {
    tokens: [number, number][];
    index: number = 0;
    previousIndex: number = 0;
    mode: "none" | "pending" | "select" = "none";
    constructor(text: string) {
        this.tokens = this.getTextTokenIdx(text);
    }

    set text(text: string) {
        this.tokens = this.getTextTokenIdx(text);
        this.mode = "none";
        this.index = 0;
        this.previousIndex = 0;
    }

    afterAnnotationIndex() {
        this.mode = "pending";
        this.move("right");
    }

    saveIndex() {
        this.previousIndex = this.index;
    }

    restoreIndex() {
        this.index = this.previousIndex;
    }

    private getTextTokenIdx(text: string) {
        text = text.slice(0, text.length - 1);
        const temp = [...text.matchAll(/,?\s/g)].flatMap((e) => [
            (e.index ?? 1) - 1,
            (e.index ?? 1) + e[0].length,
        ]);
        const pairup = _.chunk([0, ...temp, text.length - 1], 2) as [
            number,
            number
        ][];
        return pairup;
    }

    hoistCursor() {
        switch (this.mode) {
            case "none":
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "select";
                this.saveIndex();
            default:
                this.mode = "select";
                break;
        }
    }

    lowerCursor() {
        switch (this.mode) {
            case "select":
                this.restoreIndex();
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "none";
                this.index = 0;
                break;
            default:
                this.mode = "none";
                this.index = 0;
                break;
        }
    }

    moveRight() {
        this.move("right", 1);
    }
    moveLeft() {
        this.move("left", 1);
    }
    moveRight5() {
        this.move("right", 5);
    }
    moveLeft5() {
        this.move("left", 5);
    }

    move(direction: "left" | "right", step: number = 1) {
        const temp = {
            left: this.index - step,
            right: this.index + step,
        }[direction];
        this.index = _.clamp(temp, 0, this.tokens.length - 1);
    }

    get position() {
        switch (this.mode) {
            case "none":
                return this.tokens[0];
            case "pending":
                return this.tokens[this.index];
            case "select":
                const [preSelStart, preSelEnd] =
                    this.tokens[this.previousIndex];
                const [curSelStart, curSelEnd] = this.tokens[this.index];
                return (
                    this.previousIndex < this.index
                        ? [preSelStart, curSelEnd]
                        : [curSelStart, preSelEnd]
                ) as Span;

            default:
                return [0, 0] as Span;
        }
    }
}

export type CategoryVModel = {
    id: number;
    text: string;
};

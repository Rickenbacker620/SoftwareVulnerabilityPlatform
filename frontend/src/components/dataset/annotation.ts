export class AnnotationVModel {
    text: string;
    length: number;
    private _cursor: CursorVModel;
    private _annotations: AnnotationSpan[] = [];

    constructor(text: string) {
        this.text = text;
        this.length = text.length;
        this._cursor = new CursorVModel(text);
    }

    public hoistCursor() {
        const cursor = this._cursor;
        if (cursor.cursorMode === "none") cursor.cursorMode = "pending";
        else if (cursor.cursorMode === "pending") cursor.cursorMode = "select";
        else cursor.cursorMode = "select";
    }

    public lowerCursor() {
        const cursor = this._cursor;
        if (cursor.cursorMode === "select") cursor.cursorMode = "pending";
        else if (cursor.cursorMode === "pending") cursor.cursorMode = "none";
        else cursor.cursorMode = "none";
    }

    public moveLeft() {
        this._cursor.moveLeft();
    }
    public moveRight() {
        this._cursor.moveRight();
    }
    public moveLeft5() {
        this._cursor.moveLeft5();
    }
    public moveRight5() {
        this._cursor.moveRight5();
    }
    private get cursorPosition() {
        return this._cursor.cursorPosition;
    }

    private fillPlain(annotations: AnnotationSpan[]) {
        const temp = annotations.flatMap(
            function(v) {
                if (this.idx === v.start) {
                    this.idx = v.end + 1;
                    return [v];
                } else {
                    const plain = new AnnotationSpan(
                        this.idx,
                        v.start - 1,
                        "plain"
                    );
                    this.idx = v.end + 1;
                    return [plain, v];
                }
            },
            { idx: 0 }
        );

        const last = temp[temp.length - 1];
        if (last.end + 1 != this.length)
            temp.push(new AnnotationSpan(last.end + 1, this.length, "plain"));
        temp.forEach(e => (e.text = this.text.slice(e.start, e.end + 1)));
        return temp;
    }

    get annotations() {
        if (this._cursor.cursorMode === "none") {
            return this.fillPlain(this._annotations);
        } else if (this._cursor.cursorMode === "pending") {
            const temp = this.annotationWithCursor(
                this.cursorPosition,
                "pending"
            );
            return this.fillPlain(temp);
        } else {
            const temp = this.annotationWithCursor(
                this.cursorPosition,
                "select"
            );
            return this.fillPlain(temp);
        }
    }

    public addAnnotation(annotation: AnnotationSpan): void {
        this._annotations.push(annotation);
        this._annotations.sort((a, b) => a.start - b.start);
    }

    public annotationWithCursor(
        [start, end]: [number, number],
        mode: string
    ): AnnotationSpan[] {
        const cursor = new AnnotationSpan(start, end, mode);
        const copy = [...this._annotations];
        const temp = copy.filter(
            e =>
                !(
                    e.start.between(cursor.start, cursor.end) ||
                    e.end.between(cursor.start, cursor.end)
                )
        );
        temp.push(cursor);
        temp.sort((a, b) => a.start - b.start);
        return temp;
    }
}

declare global {
    export interface Number {
        between(lower: number, upper: number): boolean;
    }
}
Number.prototype.between = function(
    this: number,
    lower: number,
    upper: number
) {
    return lower <= this && this <= upper;
};

export class AnnotationSpan {
    start: number;
    end: number;
    category: string;
    text?: string;

    constructor(start: number, end: number, category: string) {
        this.start = start;
        this.end = end;
        this.category = category;
    }
}

export const getTextTokenIdx = (text: string): [number, number][] => {
    const temp = [...text.matchAll(/,?\s/g)].flatMap(e => [
        (e.index ?? 1) - 1,
        (e.index ?? 1) + e[0].length
    ]);
    const pairup = [0, ...temp, text.length - 1].flatMap((v, i, arr) => {
        if (i % 2 != 0) return [];
        else return [[v, arr[i + 1]] as [number, number]];
    });
    return pairup;
};

class CursorVModel {
    tokens: [number, number][];
    index: number = 0;
    cursorMode: "none" | "pending" | "select" = "none";
    constructor(text: string) {
        this.tokens = this.getTextTokenIdx(text);
    }

    private getTextTokenIdx(text: string): [number, number][] {
        const temp = [...text.matchAll(/,?\s/g)].flatMap(e => [
            (e.index ?? 1) - 1,
            (e.index ?? 1) + e[0].length
        ]);
        const pairup = [0, ...temp, text.length - 1].flatMap((v, i, arr) => {
            if (i % 2 != 0) return [];
            else return [[v, arr[i + 1]] as [number, number]];
        });
        return pairup;
    }

    moveLeft() {
        this.index--;
        if (this.index < 0) this.index = 0;
    }
    moveRight() {
        this.index++;
        if (this.index > this.tokens.length - 1)
            this.index = this.tokens.length - 1;
    }

    moveLeft5() {
        this.index -= 5;
        if (this.index < 0) this.index = 0;
    }

    moveRight5() {
        this.index += 5;
        if (this.index > this.tokens.length - 1)
            this.index = this.tokens.length - 1;
    }

    public get cursorPosition() {
        return this.tokens[this.index];
    }
}

import _ from "lodash-es";
import * as service from "@/utils/service";

export class AnnotationVModel {
    text: string;
    length: number;
    private _cursor!: CursorVModel;
    private _annotations: AnnotationSpan[] = [];
    private readonly _actionTable: { [key: string]: () => void };

    constructor(text: string) {
        this.text = text;
        this.length = text.length;
        this._cursor = new CursorVModel(text);
        this._actionTable = {
            right: this._cursor.moveRight,
            left: this._cursor.moveLeft,
            "ctrl+right": this._cursor.moveRight5,
            "ctrl+left": this._cursor.moveLeft5,
            esc: this._cursor.lowerCursor,
            space: this._cursor.hoistCursor
        };
    }

    cursorAction(key: string) {
        this._actionTable[key].call(this._cursor);
    }

    private fillPlain(annotations: AnnotationSpan[]) {
        const temp = annotations.flatMap(
            function(v) {
                if (this.idx === v.start) {
                    this.idx = v.end + 1;
                    return [v];
                } else {
                    const plain = new AnnotationSpan(
                        this.idx,
                        v.start - 1,
                        "plain"
                    );
                    this.idx = v.end + 1;
                    return [plain, v];
                }
            },
            { idx: 0 }
        );

        const last = _.last(temp);
        if (last!.end + 1 != this.length)
            temp.push(new AnnotationSpan(last!.end + 1, this.length, "plain"));
        temp.forEach(e => (e.text = this.text.slice(e.start, e.end + 1)));
        return temp;
    }

    get cursorPosition() {
        return this._cursor.position;
    }

    get annotations() {
        let temp: AnnotationSpan[];
        if (this._cursor.mode === "none") {
            temp = this._annotations;
        } else if (this._cursor.mode === "pending") {
            temp = this.annotationWithCursor(this.cursorPosition, "pending");
        } else {
            temp = this.annotationWithCursor(this.cursorPosition, "select");
        }
        return this.fillPlain(temp);
    }

    addAnnotation(...annotations: AnnotationSpan[]): void {
        this._annotations.push(...annotations);
        this._annotations.sort((a, b) => a.start - b.start);
    }

    addNewAnnotation(annotation: AnnotationSpan): void {
        if (this._cursor.mode === "select") {
            this.addAnnotation(annotation);
            this._cursor.afterAnnotationIndex();
        }
    }

    annotationWithCursor(
        [start, end]: [number, number],
        mode: string
    ): AnnotationSpan[] {
        const cursor = new AnnotationSpan(start, end, mode);
        const copy = [...this._annotations];
        const temp = copy.filter(
            e => e.start > cursor.end || e.end < cursor.start
        );
        temp.push(cursor);
        temp.sort((a, b) => a.start - b.start);
        return temp;
    }
}

export class AnnotationSpan {
    start: number;
    end: number;
    category: string;
    text?: string;

    constructor(start: number, end: number, category: string) {
        this.start = start;
        this.end = end;
        this.category = category;
    }
}

class CursorVModel {
    tokens: [number, number][];
    index: number = 0;
    previousIndex: number = 0;
    mode: "none" | "pending" | "select" = "none";
    constructor(text: string) {
        this.tokens = this.getTextTokenIdx(text);
    }

    afterAnnotationIndex() {
        this.mode = "pending";
        this.moveRight();
    }

    saveIndex() {
        this.previousIndex = this.index;
    }

    restoreIndex() {
        this.index = this.previousIndex;
    }

    private getTextTokenIdx(text: string) {
        const temp = [...text.matchAll(/,?\s/g)].flatMap(e => [
            (e.index ?? 1) - 1,
            (e.index ?? 1) + e[0].length
        ]);
        const pairup = _.chunk([0, ...temp, text.length - 1], 2) as [
            number,
            number
        ][];
        return pairup;
    }

    public hoistCursor() {
        switch (this.mode) {
            case "none":
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "select";
                this.saveIndex();
            default:
                this.mode = "select";
                break;
        }
    }

    public lowerCursor() {
        switch (this.mode) {
            case "select":
                this.restoreIndex();
                this.mode = "pending";
                break;
            case "pending":
                this.mode = "none";
                this.index = 0;
                break;
            default:
                this.mode = "none";
                this.index = 0;
                break;
        }
    }

    moveRight() {
        this.move("right", 1);
    }
    moveLeft() {
        this.move("left", 1);
    }
    moveRight5() {
        this.move("right", 5);
    }
    moveLeft5() {
        this.move("left", 5);
    }

    move(direction: "left" | "right", step: number = 1) {
        const temp = {
            left: this.index - step,
            right: this.index + step
        }[direction];
        this.index = _.clamp(temp, 0, this.tokens.length - 1);
    }

    get position() {
        if (this.mode === "none") {
            return this.tokens[0];
        } else if (this.mode === "pending") {
            return this.tokens[this.index];
        } else {
            const [preSelStart, preSelEnd] = this.tokens[this.previousIndex];
            const [curSelStart, curSelEnd] = this.tokens[this.index];
            return (this.previousIndex < this.index
                ? [preSelStart, curSelEnd]
                : [curSelStart, preSelEnd]) as [number, number];
        }
    }
}

export type CategoryVModel = {
    text: string;
    name: string;
};

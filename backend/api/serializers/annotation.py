
from auto_labeling_pipeline.models import RequestModelFactory
from django.conf import settings
from django.contrib.auth import get_user_model
from django.shortcuts import get_object_or_404
from rest_framework import serializers
from rest_framework.exceptions import ValidationError


from ..models.annotation import *


# class LabelSerializer(serializers.ModelSerializer):

#     def validate(self, attrs):
#         prefix_key = attrs.get('prefix_key')
#         suffix_key = attrs.get('suffix_key')

#         # In the case of user don't set any shortcut key.
#         if prefix_key is None and suffix_key is None:
#             return super().validate(attrs)

#         # Don't allow shortcut key not to have a suffix key.
#         if prefix_key and not suffix_key:
#             raise ValidationError('Shortcut key may not have a suffix key.')

#         # Don't allow to save same shortcut key when prefix_key is null.
#         try:
#             context = self.context['request'].parser_context
#             project_id = context['kwargs']['project_id']
#             label_id = context['kwargs'].get('label_id')
#         except (AttributeError, KeyError):
#             pass  # unit tests don't always have the correct context set up
#         else:
#             conflicting_labels = Label.objects.filter(
#                 suffix_key=suffix_key,
#                 prefix_key=prefix_key,
#                 project=project_id,
#             )

#             if label_id is not None:
#                 conflicting_labels = conflicting_labels.exclude(id=label_id)

#             if conflicting_labels.exists():
#                 raise ValidationError('Duplicate shortcut key.')

#         return super().validate(attrs)

#     class Meta:
#         model = Label
#         fields = ('id', 'text', 'prefix_key', 'suffix_key', 'background_color', 'text_color')


# class CategorySerializer(serializers.ModelSerializer):
#     label = serializers.PrimaryKeyRelatedField(queryset=Label.objects.all())
#     example = serializers.PrimaryKeyRelatedField(queryset=Dataset.objects.all())

#     class Meta:
#         model = Category
#         fields = (
#             'id',
#             'prob',
#             'user',
#             'example',
#             'created_at',
#             'updated_at',
#             'label',
#         )
#         read_only_fields = ('user',)


# class SpanSerializer(serializers.ModelSerializer):
#     label = serializers.PrimaryKeyRelatedField(queryset=Label.objects.all())
#     example = serializers.PrimaryKeyRelatedField(queryset=Dataset.objects.all())

#     class Meta:
#         model = Span
#         fields = (
#             'id',
#             'prob',
#             'user',
#             'example',
#             'created_at',
#             'updated_at',
#             'label',
#             'start_offset',
#             'end_offset',
#         )
#         read_only_fields = ('user',)


# # def get_annotation_serializer(task: str):
# #     mapping = {
# #         DOCUMENT_CLASSIFICATION: CategorySerializer,
# #         SEQUENCE_LABELING: SpanSerializer,
# #         SEQ2SEQ: TextLabelSerializer,
# #         SPEECH2TEXT: TextLabelSerializer,
# #         IMAGE_CLASSIFICATION: CategorySerializer,
# #     }
# #     try:
# #         return mapping[task]
# #     except KeyError:
# #         raise ValueError(f'{task} is not implemented.')


# class RelationTypesSerializer(serializers.ModelSerializer):

#     def validate(self, attrs):
#         return super().validate(attrs)

#     class Meta:
#         model = RelationTypes
#         fields = ('id', 'color', 'name')


# class AnnotationRelationsSerializer(serializers.ModelSerializer):

#     def validate(self, attrs):
#         return super().validate(attrs)

#     class Meta:
#         model = AnnotationRelations
#         fields = ('id', 'annotation_id_1', 'annotation_id_2', 'type', 'user', 'timestamp')


class AnnotationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Annotation
        fields = ('start_offset', 'end_offset')

import re
from datetime import datetime
from typing import List, Optional

import pymongo
from fastapi import APIRouter, Depends, HTTPException
from pymongo.database import Database
from pymongo.operations import UpdateOne

from app.api.utils import PaginationParams, get_current_user
from app.core.db import get_db
from app.schemas import DatasetDetailSchema, DatasetSchema, \
    AnnotationTaskCreateSchema, Status
from app.schemas.dataset import TaskSchema
from app.schemas.user import UserSchema

router = APIRouter()


@router.get(
    "/",
    response_model=List[DatasetSchema]
)
async def get_datasets(db: Database = Depends(get_db), page: PaginationParams = Depends(),
                       annotated: Optional[bool] = None, ambiguous: Optional[bool] = None,
                       approved: Optional[bool] = None, order: int = 0, q: str = None):
    collection = db["datasets"]

    query_dict = {"annotation": {"$exists": True}}
    if annotated is not None:
        query_dict["annotation.annotated"] = annotated

    if ambiguous is not None:
        query_dict["annotation.ambiguous"] = ambiguous

    if approved is not None:
        query_dict["annotation.approved"] = approved

    if q is not None:
        regex = re.compile(f".*{q}.*")
        query_dict["_id"] = regex

    datasets = collection.find(filter=query_dict)

    if order == 0:
        datasets = datasets.sort("annotation.modified_at", pymongo.ASCENDING)

    if order == 1:
        datasets = datasets.sort("annotation.modified_at", pymongo.DESCENDING)

    datasets = datasets.skip(page.offset).limit(page.limit)

    return list(datasets)


@router.get(
    "/my-tasks",
    response_model=List[TaskSchema]
)
async def get_my_task(db: Database = Depends(get_db), user: UserSchema = Depends(get_current_user)):
    collection = db["tasks"]
    tasks = collection.find(projection={"_id": False}).sort(
        [("created_at", pymongo.DESCENDING)])
    tasks = list(tasks)
    for task in tasks:
        flag = False
        for detail in task["detail"]:
            if detail["user"] == user.username:
                flag = True
                dataset_ids = detail["datasets"]
                datasets = list(db["datasets"].find(
                    {"_id": {"$in": dataset_ids}}))
                datasets.sort(
                    key=lambda dataset: dataset["annotation"]["modified_at"], reverse=True)
                datasets.sort(
                    key=lambda dataset: dataset["annotation"]["annotated"])
                task["detail"] = datasets
                break
        if not flag:
            task["detail"] = []

    return tasks


@router.post(
    "/make-task",
    response_model=Status
)
async def make_task(db: Database = Depends(get_db), *, task: AnnotationTaskCreateSchema):
    users = list(db["users"].find(projection={"_id": False, "password": False}))
    total_count = len(users) * task.size

    annotation_empty = {
        "ambiguous": False,
        "annotated": False,
        "approved": False,
        "invalid": False,
        "modified_at": datetime.now(),
        "annotations": []
    }

    task_obj = {
        "name": task.name,
        "created_at": datetime.now(),
        "detail": []
    }

    bulk_request = []
    counter = 0
    dataset_group = []
    for doc in db["datasets"].find({"annotation": {"$exists": False}}).limit(total_count):

        counter += 1
        dataset_group.append(doc["_id"])

        if counter % task.size == 0:
            print(dataset_group)
            user_index = counter // task.size - 1
            task_obj["detail"].append(
                {"user": users[user_index]["username"], "datasets": [*dataset_group]})
            dataset_group.clear()

        bulk_request.append(UpdateOne({"_id": doc["_id"]}, {
            "$set": {"annotation": annotation_empty}}))

    db["tasks"].insert_one(task_obj)

    db["datasets"].bulk_write(bulk_request)

    return Status(message=f"任务{task.name}创建成功")


@router.get(
    "/{dataset_id}",
    response_model=DatasetDetailSchema
)
async def get_dataset(db: Database = Depends(get_db), *, dataset_id: str):
    collection = db["datasets"]
    dataset = collection.find_one({"_id": dataset_id})

    if dataset is None:
        raise HTTPException(status_code=404, detail="未找到该CVE")

    return dataset


@router.post(
    "/{dataset_id}/status",
    response_model=Status
)
async def toggle_status(db: Database = Depends(get_db), *, dataset_id: str, option: str = None):
    if option not in ["invalid", "ambiguous", "approved"]:
        raise HTTPException(status_code=404, detail="无效操作")
    collection = db["datasets"]
    dataset = collection.find_one({"_id": dataset_id})
    set_val = not dataset["annotation"][option]
    collection.find_one_and_update(
        {"_id": dataset_id},
        {"$set": {"annotation." + option: set_val}, "$set": {"annotation.modified_at": datetime.now()}})
    return Status(message="操作成功")

import collections
from optparse import Option
import re
from datetime import datetime
from typing import List, Optional

import pymongo
from app.api.utils import get_current_user
from app.core.db import get_db
from app.schemas import (AnnotationTaskCreateSchema, DatasetDetailSchema,
                         DatasetSchema, Status)
from app.schemas.dataset import DatasetListSchema, StatsSchema, TaskSchema
from app.schemas.user import UserSchema
from fastapi import APIRouter, Depends, HTTPException
from pymongo.database import Database
from pymongo.operations import UpdateOne

from app.schemas.extra import DatasetFilterParam

router = APIRouter()


@router.get(
    "/",
    response_model=DatasetListSchema
)
async def get_datasets(db: Database = Depends(get_db),
                       filter: DatasetFilterParam = Depends()
                       ):

    wanted_tags = [key for key, value in filter.status_dict.items()
                   if value is True]
    unwanted_tags = [key for key,
                     value in filter.status_dict.items() if value is False]

    collection = db["datasets"]

    query_dict = {"annotation": {"$exists": True}, "selected": True,
                  "annotation.tags": {"$all": wanted_tags, "$nin": unwanted_tags}}

    if filter.q:
        regex = re.compile(f".*{filter.q}.*")
        query_dict["_id"] = regex

    datasets = collection.find(filter=query_dict)

    match filter.order:
        case None:
            datasets = datasets.sort(
                "annotation.modified_at", pymongo.ASCENDING)
        case 0:
            datasets = datasets.sort("_id", pymongo.ASCENDING)
        case 1:
            datasets = datasets.sort("_id", pymongo.DESCENDING)
        case _:
            datasets = datasets.sort("_id", pymongo.ASCENDING)

    count = collection.count_documents(filter=query_dict)

    datasets = datasets.skip(filter.page.offset).limit(filter.page.limit)

    result = {"count": count, "list": list(datasets)}

    return result


@router.get(
    "/my-tasks",
    response_model=List[TaskSchema]
)
async def get_my_task(db: Database = Depends(get_db), user: UserSchema = Depends(get_current_user)):
    collection = db["tasks"]
    tasks = collection.find(projection={"_id": False}).sort(
        [("created_at", pymongo.DESCENDING)])
    tasks = list(tasks)
    for task in tasks:
        flag = False
        for detail in task["detail"]:
            if detail["user"] == user.username:
                flag = True
                dataset_ids = detail["datasets"]
                datasets = list(db["datasets"].find(
                    {"_id": {"$in": dataset_ids}}))
                datasets.sort(
                    key=lambda dataset: dataset["annotation"]["modified_at"], reverse=True)
                datasets.sort(
                    key=lambda dataset: "annotated" in dataset["annotation"]["tags"])
                task["detail"] = datasets
                break
        if not flag:
            task["detail"] = []

    tasks = [task for task in tasks if task["detail"] != []]

    return tasks


@router.get("/stats", response_model=List[StatsSchema])
async def stats(db: Database = Depends(get_db)):
    datasets_collection = db["datasets"]
    tasks_collection = db["tasks"]
    users_collection = db["users"]
    users = list(users_collection.find({"role": "annotator"},
                                       projection={"_id": False, "password": False, "role": False}))

    result = []

    for user in users:
        total = 0
        annotated = 0
        for task in tasks_collection.find():
            for detail in task["detail"]:
                if detail["user"] == user["username"]:
                    dataset_ids = detail["datasets"]
                    datasets = list(db["datasets"].find(
                        {"_id": {"$in": dataset_ids}}))
                    for dataset in datasets:
                        total += 1
                        if "annotated" in dataset["annotation"] or "invalid" in dataset["annotation"]:
                            annotated += 1
        result.append({"user": user["username"],
                      "annotated": annotated, "total": total})

    return result


@router.post(
    "/make-task",
    # response_model=Status
)
async def make_task(db: Database = Depends(get_db), *, task: AnnotationTaskCreateSchema):
    if task.task_type == "annotate":
        users = list(db["users"].find(
            projection={"_id": False, "password": False}))
        users.remove({'username': 'yby', 'role': 'annotator'})
        users.remove({'username': 'lyj', 'role': 'annotator'})
        users = [
            user for user in users if not user["username"].startswith("user")]
        task_candidate_dict = {"annotation": {
            "$exists": False}, "selected": True}
    else:
        users = list(db["users"].find(
            projection={"_id": False, "password": False}))
        users = [user for user in users if user["username"].startswith("user")]
        task_candidate_dict = {"annotation.annotated": True,
                               "selected": True, "annotation.classified": False}

    total_count = len(users) * task.size

    annotation_empty = {
        "tags": [],
        "modified_at": datetime.now(),
        "annotations": []
    }

    task_obj = {
        "name": task.name,
        "created_at": datetime.now(),
        "detail": []
    }

    bulk_request = []
    counter = 0
    dataset_group = []
    for doc in db["datasets"].find(task_candidate_dict).limit(total_count):

        counter += 1
        dataset_group.append(doc["_id"])

        if counter % task.size == 0:
            user_index = counter // task.size - 1
            task_obj["detail"].append(
                {"user": users[user_index]["username"], "datasets": [*dataset_group]})
            dataset_group.clear()

        if task.task_type == "annotate":
            bulk_request.append(UpdateOne({"_id": doc["_id"]}, {
                "$set": {"annotation": annotation_empty}}))

    db["tasks"].insert_one(task_obj)

    if task.task_type == "annotate":
        db["datasets"].bulk_write(bulk_request)

    return Status(message=f"任务{task.name}创建成功")


@router.get(
    "/{dataset_id}",
    response_model=DatasetDetailSchema
)
async def get_dataset(db: Database = Depends(get_db), *, dataset_id: str):
    collection = db["datasets"]
    dataset = collection.find_one({"_id": dataset_id})

    if dataset is None:
        raise HTTPException(status_code=404, detail="未找到该CVE")

    return dataset


@router.post(
    "/{dataset_id}/status",
    response_model=Status
)
async def toggle_status(db: Database = Depends(get_db), *, dataset_id: str, option: str | None = None):
    if option not in ["invalid", "ambiguous", "approved", "example"]:
        raise HTTPException(status_code=404, detail="无效操作")
    collection = db["datasets"]
    dataset = collection.find_one(
        {"_id": dataset_id, "annotation.tags": option})
    operation = "$pull" if dataset else "$addToSet"
    collection.find_one_and_update(
        {"_id": dataset_id},
        {operation: {"annotation.tags": option},
         "$set": {"annotation.modified_at": datetime.now()}
         }
    )
    return Status(message="操作成功")

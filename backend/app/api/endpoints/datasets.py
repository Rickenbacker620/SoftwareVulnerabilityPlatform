import collections
from optparse import Option
import re
from datetime import datetime
from typing import List, Optional

import pymongo
from app.api.utils import PaginationParams, get_current_user
from app.core.db import get_db
from app.schemas import (AnnotationTaskCreateSchema, DatasetDetailSchema,
                         DatasetSchema, Status)
from app.schemas.dataset import DatasetListSchema, StatsSchema, TaskSchema
from app.schemas.user import UserSchema
from fastapi import APIRouter, Depends, HTTPException
from pymongo.database import Database
from pymongo.operations import UpdateOne

router = APIRouter()


@router.get(
    "/",
    response_model=DatasetListSchema
)
async def get_datasets(db: Database = Depends(get_db),
                       page: PaginationParams = Depends(),
                       annotated: Optional[bool] = None,
                       ambiguous: Optional[bool] = None,
                       approved: Optional[bool] = None,
                       invalid: Optional[bool] = None,
                       example: Optional[bool] = None,
                       order: Optional[int] = None,
                       q: str = None):
    collection = db["datasets"]

    query_dict = {"annotation": {"$exists": True}, "has_github": True}

    if annotated:
        query_dict["annotation.annotated"] = annotated

    if ambiguous:
        query_dict["annotation.ambiguous"] = ambiguous

    if approved:
        query_dict["annotation.approved"] = approved

    if invalid:
        query_dict["annotation.invalid"] = invalid

    if example:
        query_dict["annotation.example"] = example

    if q:
        regex = re.compile(f".*{q}.*")
        query_dict["_id"] = regex



    datasets = collection.find(filter=query_dict)

    if order is None:
        datasets = datasets.sort("annotation.modified_at", pymongo.ASCENDING)
    elif order == 0:
        datasets = datasets.sort("_id", pymongo.ASCENDING)
    else:
        datasets = datasets.sort("_id", pymongo.DESCENDING)


    # .sort("_id", pymongo.ASCENDING)

    count = collection.count_documents(filter=query_dict)

    # if order == 0:
    #     datasets = datasets.sort("annotation.modified_at", pymongo.ASCENDING)

    # if order == 1:
    #     datasets = datasets.sort("annotation.modified_at", pymongo.DESCENDING)

    # if order == 2:
    #     datasets = datasets.sort("_id", pymongo.ASCENDING)

    # if order == 3:
    #     datasets = datasets.sort("_id", pymongo.DESCENDING)

    datasets = datasets.skip(page.offset).limit(page.limit)

    result = {"count": count, "list": list(datasets)}

    return result


@router.get(
    "/my-tasks",
    response_model=List[TaskSchema]
)
async def get_my_task(db: Database = Depends(get_db), user: UserSchema = Depends(get_current_user)):
    collection = db["tasks"]
    tasks = collection.find(projection={"_id": False}).sort(
        [("created_at", pymongo.DESCENDING)])
    tasks = list(tasks)
    for task in tasks:
        flag = False
        for detail in task["detail"]:
            if detail["user"] == user.username:
                flag = True
                dataset_ids = detail["datasets"]
                datasets = list(db["datasets"].find(
                    {"_id": {"$in": dataset_ids}}))
                datasets.sort(
                    key=lambda dataset: dataset["annotation"]["modified_at"], reverse=True)
                datasets.sort(
                    key=lambda dataset: dataset["annotation"]["annotated"])
                task["detail"] = datasets
                break
        if not flag:
            task["detail"] = []

    return tasks

@router.get("/stats", response_model=List[StatsSchema])
async def stats(db: Database = Depends(get_db)):
    datasets_collection = db["datasets"]
    tasks_collection = db["tasks"]
    users_collection = db["users"]
    users = list(users_collection.find({"role":"annotator"},
        projection={"_id": False, "password": False,"role":False}))

    result = []

    for user in users:
        total = 0
        annotated = 0
        for task in tasks_collection.find():
            for detail in task["detail"]:
                if detail["user"] == user["username"]:
                    dataset_ids = detail["datasets"]
                    datasets = list(db["datasets"].find({"_id": {"$in": dataset_ids}}))
                    for dataset in datasets:
                        total += 1
                        if dataset["annotation"]["annotated"] == True or dataset["annotation"]["invalid"] == True:
                            annotated += 1
        result.append({"user": user["username"], "annotated": annotated, "total": total})

    return result


@router.post(
    "/make-task",
    response_model=Status
)
async def make_task(db: Database = Depends(get_db), *, task: AnnotationTaskCreateSchema):
    users = list(db["users"].find(
        projection={"_id": False, "password": False}))
    total_count = len(users) * task.size

    annotation_empty = {
        "ambiguous": False,
        "annotated": False,
        "approved": False,
        "invalid": False,
        "example": False,
        "modified_at": datetime.now(),
        "annotations": []
    }

    task_obj = {
        "name": task.name,
        "created_at": datetime.now(),
        "detail": []
    }

    bulk_request = []
    counter = 0
    dataset_group = []
    for doc in db["datasets"].find({"annotation": {"$exists": False}, "has_github": True}).limit(total_count):

        counter += 1
        dataset_group.append(doc["_id"])

        if counter % task.size == 0:
            print(dataset_group)
            user_index = counter // task.size - 1
            task_obj["detail"].append(
                {"user": users[user_index]["username"], "datasets": [*dataset_group]})
            dataset_group.clear()

        bulk_request.append(UpdateOne({"_id": doc["_id"]}, {
            "$set": {"annotation": annotation_empty}}))

    db["tasks"].insert_one(task_obj)

    db["datasets"].bulk_write(bulk_request)

    return Status(message=f"任务{task.name}创建成功")


@router.get(
    "/{dataset_id}",
    response_model=DatasetDetailSchema
)
async def get_dataset(db: Database = Depends(get_db), *, dataset_id: str):
    collection = db["datasets"]
    dataset = collection.find_one({"_id": dataset_id})

    if dataset is None:
        raise HTTPException(status_code=404, detail="未找到该CVE")

    return dataset


@router.post(
    "/{dataset_id}/status",
    response_model=Status
)
async def toggle_status(db: Database = Depends(get_db), *, dataset_id: str, option: str = None):
    if option not in ["invalid", "ambiguous", "approved", "example"]:
        raise HTTPException(status_code=404, detail="无效操作")
    collection = db["datasets"]
    dataset = collection.find_one({"_id": dataset_id})
    set_val = not dataset["annotation"][option]
    collection.find_one_and_update(
        {"_id": dataset_id},
        {"$set": {"annotation." + option: set_val, "annotation.modified_at": datetime.now()}})
    return Status(message="操作成功")


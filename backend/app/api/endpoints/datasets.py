from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException
from tortoise.functions import Count

from app.api.utils import PaginationParams, get_current_user
from app.models import Dataset, Annotation, User, CVEInfo
from app.schemas import DatasetDetailSchema, AnnotationSchema, DatasetSchema, \
    AnnotationTaskCreateSchema, Status

router = APIRouter()


@router.get(
    "/",
    response_model=List[DatasetSchema]
)
async def get_datasets(page: PaginationParams = Depends(), annotated: bool = True):
    if annotated is False:
        queryset = CVEInfo.all().order_by("cve_no").offset(page.offset).limit(page.limit)
        return [DatasetSchema(cve_id=e.cve_no, approved=None, ambiguous=None, last_modified=None,
                              description=e.description) for e in await queryset]

    queryset = Dataset.all()
    if annotated is True:
        annotated_dataset_list = await Annotation.all().offset(page.offset).limit(page.limit).distinct().values_list(
            "cve_id", flat=True)
        queryset = queryset.filter(cve_id__in=annotated_dataset_list)

    queryset = queryset.offset(page.offset).limit(page.limit).prefetch_related("cve")
    return [
        DatasetSchema(cve_id=e.pk, approved=e.approved, ambiguous=e.ambiguous, last_modified=e.modified_at,
                      description=e.cve.description) for e in await queryset]


@router.get(
    "/my-tasks",
    response_model=List[DatasetSchema]
)
async def get_my_tasks(user: User = Depends(get_current_user), page: PaginationParams = Depends(),
                       annotated: Optional[bool] = None, ambiguous: bool=False, approved:bool=False):
    queryset = Dataset.filter(user=user)

    if annotated is not None:
        annotated_dataset_list = await Annotation.all().distinct().values_list("cve_id", flat=True)

        if annotated is True:
            queryset = queryset.filter(cve_id__in=annotated_dataset_list)

        if annotated is False:
            queryset = queryset.filter(cve_id__not_in=annotated_dataset_list)

    queryset = queryset.filter(ambiguous=ambiguous, approved=approved)

    queryset = queryset.offset(page.offset).limit(page.limit).order_by("-modified_at").prefetch_related("cve")

    return [DatasetSchema(cve_id=e.pk, approved=e.approved, ambiguous=e.ambiguous, last_modified=e.modified_at,
                          description=e.cve.description) for e in await queryset]


@router.post(
    "/make-task",
    response_model=Status
)
async def make_task(task: AnnotationTaskCreateSchema):
    users = await User.all()

    datasets = await Dataset.annotate(annotations_count=Count(
        "annotations")).filter(annotations_count=0, task=None).limit(task.size * len(users))

    for idx, annotator in enumerate(users):
        start = idx * task.size
        end = start + task.size
        ds = datasets[start:end]
        await Dataset.bulk_create([
            Dataset(name=task.name, user=annotator, dataset=i) for i in ds
        ])

    return Status(message=f"Created Success {task.name}")


@router.get(
    "/{dataset_id}",
    response_model=DatasetDetailSchema
)
async def get_dataset(dataset_id: int):
    return await Dataset.get(id=dataset_id).prefetch_related("cve", "annotations_approved_by")


@router.post(
    "/finish-annotation/{dataset_id}",
    response_model=Status
)
async def finish_annotation(dataset_id: int, user=Depends(get_current_user)):
    task = await AnnotationTask.filter(dataset_id=dataset_id, user=user).first()
    if (task is not None):
        task.done = True
        await task.save()
        return Status(message="success")
    else:
        raise HTTPException(status_code=404, detail=f"Cannot finish task")


@router.get(
    "/{dataset_id}/annotations",
    response_model=List[AnnotationSchema]
)
async def get_dataset_annotations(dataset_id: int):
    return await Annotation.filter(dataset__id=dataset_id)


@router.post(
    "/{dataset_id}/approve",
)
async def mark_as_approved():
    # TODO comlete controller
    pass

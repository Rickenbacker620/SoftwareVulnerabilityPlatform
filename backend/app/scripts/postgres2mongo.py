import os
from pymongo import MongoClient
from pymongo.collection import Collection
import pymongo
import csv
from dateutil import parser

from pymongo.database import Database


def get_database():

    # Provide the mongodb atlas url to connect python to mongodb using pymongo
    CONNECTION_STRING = "mongodb://localhost"

    # Create a connection using MongoClient. You can import MongoClient or use pymongo.MongoClient
    client = MongoClient(CONNECTION_STRING)

    # Create the database for our example (we will use the same database throughout the tutorial
    return client["svp"]


def insert_datasets(database: Database):
    collection = database['dataset']
    with open('/home/shiro/Projects/SoftwareVulnerabilityPlatform/backend/data/taskreborn.csv') as f:
        f_csv = csv.DictReader(f)
        for idx, row in enumerate(f_csv):
            cve_no = row['cve_no']
            modified_at = parser.parse(row['modified_at'])
            collection.update_one(
                {'cve_id': cve_no},
                {
                    '$set': {
                        'approved': False,
                        'ambiguous': False,
                        'annotated': False,
                        'modified_at': modified_at,
                        'annotations': []
                    }
                },
                upsert=True,
            )
    with open('/home/shiro/Projects/SoftwareVulnerabilityPlatform/backend/data/annotationreborn.csv') as f:
        f_csv = csv.DictReader(f)
        for idx, row in enumerate(f_csv):
            cve_no = row.pop('cve_no')
            del row['id']
            row['part'] = row.pop('text_en')
            collection.update_one(
                {'cve_id': cve_no},
                {
                    '$addToSet': {
                        'annotations': row
                    },
                },
                upsert=True,
            )


def insert_users(database: Database):
    collection = database['user']
    with open('/home/shiro/Projects/SoftwareVulnerabilityPlatform/backend/data/rolereborn.csv') as f:
        f_csv = csv.DictReader(f)
        for idx, row in enumerate(f_csv):
            username = row.pop('username')
            del row['id']
            row['role'] = row.pop('name')
            row['password'] = row.pop('password_hash')
            collection.update_one(
                {'username': username},
                {'$set': row},
                upsert=True
            )


def insert_tasks(database: Database):
    collection = database['task']
    with open('/home/shiro/Projects/SoftwareVulnerabilityPlatform/backend/data/rolereborn.csv') as f:
        f_csv = csv.DictReader(f)
        user_list = [row for row in f_csv]

    with open('/home/shiro/Projects/SoftwareVulnerabilityPlatform/backend/data/taskreborn.csv') as f:
        f_csv = csv.DictReader(f)
        for idx, row in enumerate(f_csv):
            name = row.pop('name')
            del row['id']
            del row['done']
            for user in user_list:
                if user['id'] == row['user_id']:
                    row['user'] = user['username']
            row['modified_at'] = parser.parse(row['modified_at'])
            row['created_at'] = parser.parse(row['created_at'])
            del row['user_id']

            collection.update_one(
                {'name': name},
                {
                    '$set': {
                        'created_at': row['created_at']
                    },
                    '$addToSet': {
                        'detail': {
                            'user': row['user'],
                            'cve_id': row['cve_no'],
                            'modified_at': row['modified_at']
                        }
                    }
                },
                upsert=True
            )
            # print(row)

            # if idx > 100:
            #     break

def modify_task(dbname):
    result = dbname['task'].aggregate([
        {
            '$unwind': {
                'path': '$detail'
            }
        }, {
            '$group': {
                '_id': {
                    'name': '$name',
                    'user': '$detail.user',
                    'created_at': '$created_at',
                    'origin_id': '$_id'
                },
                'user': {
                    '$first': '$detail.user'
                },
                'detail': {
                    '$push': {
                        'dataset': '$detail.cve_id',
                        'modified_at': '$detail.modified_at'
                    }
                }
            }
        }, {
            '$lookup': {
                'from': 'dataset',
                'localField': 'detail.dataset',
                'foreignField': 'cve_id',
                'as': 'detail'
            }
        }, {
            '$project': {
                'user': 1,
                'detail': '$detail._id'
            }
        }, {
            '$group': {
                '_id': {
                    'name': '$_id.name',
                    'id': '$_id.origin_id'
                },
                'name': {
                    '$first': '$_id.name'
                },
                'created_at': {
                    '$first': '$_id.created_at'
                },
                'detail': {
                    '$push': {
                        'user': '$_id.user',
                        'datasets': '$detail'
                    }
                }
            }
        }, {
            '$set': {
                '_id': '$_id.id'
            }
        }, {
            '$out' : 'task'
        }
    ])

if __name__ == "__main__":
    dbname = get_database()
    collection = dbname["dataset"]
    datasets = collection.find({"annotation": {"$exists": True}})
    for dataset in datasets:
        cve_id =  dataset["_id"]
        new_list = []
        for annotation in dataset["annotation"]["annotations"]:
            start = int(annotation["start_offset"])
            end = int(annotation["end_offset"])
            part = annotation["part"]
            new_dict = {
                "start_offset":start,
                "end_offset":end,
                "part":part
            }
            new_list.append(new_dict)
        datasets = collection.update_one({"_id": cve_id}, {
            "$set": {
                "annotation.annotations": new_list
            }
        })

    # insert_tasks(dbname)

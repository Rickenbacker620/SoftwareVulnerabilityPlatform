from copy import deepcopy
from py2neo.data import Relationship
from tortoise import Tortoise, run_async
from tortoise.functions import Count
from py2neo import Graph, Node

from app.models.dataset import Dataset
from app.models.annotation import Annotation


class DatasetObj:
    def __init__(self):
        self.raw_dict = {
            "dataset_id": "",
            "cve_no": "",
            "description": "",
            "annotations": {
                "attacker": [],
                "cause": [],
                "location": [],
                "situation": [],
                "operation": [],
                "version": [],
                "consequence": []
            }
        }

    @staticmethod
    async def parse_from(dataset):
        obj = DatasetObj()
        obj.cve_no = dataset.cve.cve_no
        obj.description = dataset.cve.description
        obj.dataset_id = dataset.pk

        annotations = await dataset.annotations
        for annotation in annotations:
            annotation: Annotation
            part = await annotation.part
            obj.raw_dict["annotations"][part.text_en].append(
                (annotation.start_offset, annotation.end_offset))
        return obj

    @property
    def cve_no(self):
        return self.raw_dict["cve_no"]

    @cve_no.setter
    def cve_no(self, value):
        self.raw_dict["cve_no"] = value

    @property
    def description(self):
        return self.raw_dict["description"]

    @description.setter
    def description(self, value):
        self.raw_dict["description"] = value

    @property
    def dataset_id(self):
        return self.raw_dict["dataset_id"]

    @dataset_id.setter
    def dataset_id(self, value):
        self.raw_dict["dataset_id"] = value

    @property
    def neo4j(self):
        dict_copy = deepcopy(self.raw_dict)
        description = dict_copy.pop("description")
        for key, value in dict_copy["annotations"].items():
            dict_copy["annotations"][key] = [
                description[annotation[0]:annotation[1]] for annotation in value]
        return dict_copy

    @property
    def spacy(self):
        return self.raw_dict


class DatasetIter:
    async def __call__(self):
        print("Searching for annotated datasets...")
        datasets = await Dataset.annotate(annotations_count=Count("annotations")).filter(annotations_count__not=0).prefetch_related("cve")
        print(f"Done searching, {len(datasets)} datasets have been counted")

        for dataset in datasets:
            dataset_obj = await DatasetObj.parse_from(dataset)
            yield dataset_obj


async def export2neo4j(graph, dataset):
    print(f"Exporting dataset {dataset.dataset_id}, {dataset.cve_no}")
    node = Node("cve", cve_no=dataset.cve_no)
    for part, texts in dataset.neo4j["annotations"].items():
        for text in texts:
            sub_node = Node(part, text=text)
            relation = Relationship(node, part.upper(), sub_node)
            graph.create(relation)


async def run():
    await Tortoise.init(
        db_url="postgres://postgres:lucifer@localhost/svp",
        modules={'models': ['app.models']},
    )
    graph = Graph(password="lucifer")
    graph.run("match (n) detach delete n")

    dataset_iter = DatasetIter()
    iter = dataset_iter()
    async for dataset in iter:
        await export2neo4j(graph, dataset)

    # relations_keys = DatasetObj.raw_dict["annotations"].keys()
    # relations_dict = {key: Relationship.type(key) for key in relations_keys}


if __name__ == "__main__":
    run_async(run())
